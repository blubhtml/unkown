<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Mini Paper.io Clone</title>
    <style>
        body { margin: 0; overflow: hidden; background: #222; font-family: sans-serif; }
        canvas { display: block; background: #fff; margin: 20px auto; box-shadow: 0 0 20px rgba(0,0,0,0.5); }
        #ui { position: absolute; top: 30px; left: 30px; color: white; pointer-events: none; }
    </style>
</head>
<body>
    <div id="ui">
        <h1>Paper.io Mini</h1>
        <p>Use <b>Arrow Keys</b> to move.<br>Capture space by returning to your color!</p>
    </div>
    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Configuration
        const gridSize = 60; 
        const tileSize = 10;
        canvas.width = gridSize * tileSize;
        canvas.height = gridSize * tileSize;

        const EMPTY = 0;
        const PLAYER_TERRITORY = 1;
        const PLAYER_TRAIL = 2;

        let grid = Array(gridSize).fill().map(() => Array(gridSize).fill(EMPTY));
        let player = { x: 5, y: 5, dx: 1, dy: 0, nextDir: [1, 0] };

        // Initialize starting territory
        for(let i=3; i<8; i++) {
            for(let j=3; j<8; j++) grid[i][j] = PLAYER_TERRITORY;
        }

        // Input handling
        window.addEventListener('keydown', e => {
            if (e.key === 'ArrowUp' && player.dy === 0) player.nextDir = [0, -1];
            if (e.key === 'ArrowDown' && player.dy === 0) player.nextDir = [0, 1];
            if (e.key === 'ArrowLeft' && player.dx === 0) player.nextDir = [-1, 0];
            if (e.key === 'ArrowRight' && player.dx === 0) player.nextDir = [1, 0];
        });

        function update() {
            player.dx = player.nextDir[0];
            player.dy = player.nextDir[1];
            
            player.x += player.dx;
            player.y += player.dy;

            // Bounds check
            if (player.x < 0 || player.x >= gridSize || player.y < 0 || player.y >= gridSize) {
                resetGame();
                return;
            }

            let currentTile = grid[player.x][player.y];

            if (currentTile === PLAYER_TRAIL) {
                resetGame(); // Hit own trail
            } else if (currentTile === EMPTY) {
                grid[player.x][player.y] = PLAYER_TRAIL;
            } else if (currentTile === PLAYER_TERRITORY) {
                captureTerritory();
            }
        }

        function captureTerritory() {
            // Convert all trail to territory
            for (let i = 0; i < gridSize; i++) {
                for (let j = 0; j < gridSize; j++) {
                    if (grid[i][j] === PLAYER_TRAIL) grid[i][j] = PLAYER_TERRITORY;
                }
            }
            // Simple logic: Any empty block surrounded by territory should fill.
            // (Note: A full flood fill algorithm would be implemented here for a complete game)
        }

        function resetGame() {
            grid = Array(gridSize).fill().map(() => Array(gridSize).fill(EMPTY));
            player = { x: 5, y: 5, dx: 1, dy: 0, nextDir: [1, 0] };
            for(let i=3; i<8; i++) {
                for(let j=3; j<8; j++) grid[i][j] = PLAYER_TERRITORY;
            }
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            for (let i = 0; i < gridSize; i++) {
                for (let j = 0; j < gridSize; j++) {
                    if (grid[i][j] === PLAYER_TERRITORY) {
                        ctx.fillStyle = '#4CAF50';
                        ctx.fillRect(i * tileSize, j * tileSize, tileSize, tileSize);
                    } else if (grid[i][j] === PLAYER_TRAIL) {
                        ctx.fillStyle = '#81C784';
                        ctx.fillRect(i * tileSize, j * tileSize, tileSize, tileSize);
                    }
                }
            }

            // Draw player head
            ctx.fillStyle = '#2E7D32';
            ctx.fillRect(player.x * tileSize, player.y * tileSize, tileSize, tileSize);
        }

        function loop() {
            update();
            draw();
            setTimeout(loop, 100); // Game speed
        }

        loop();
    </script>
</body>
</html>
